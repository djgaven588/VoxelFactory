#version 430 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

uniform mat4 _CameraToWorld;
uniform mat4 _CameraInverseProjection;
uniform ivec2 _RenderSize;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

// Generate a ray coming from the provided location on the screen
Ray CreateCameraRay(vec2 uv)
{
    vec3 origin = (_CameraToWorld * vec4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;


    Ray ray;
    ray.origin = origin;

    const vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, 1.0, 1.0);
    vec4 far = _CameraInverseProjection * clipSpacePosition;
    far /= far.w;

    ray.direction = normalize(far.xyz - ray.origin);

    /*
    vec3 direction = (_CameraInverseProjection * vec4(uv, 0.0f, 1.0f)).xyz;

    direction = (_CameraToWorld * vec4(direction, 0.0f)).xyz;
    direction = normalize(direction);
    Ray ray;*/
    
    //ray.direction = direction;
    return ray;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main(void) {
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }

    vec2 uv = vec2((pix + vec2(0.5, 0.5)) / vec2(_RenderSize.x, _RenderSize.y) * 2.0 - 1.0);

    Ray ray = CreateCameraRay(uv);

    imageStore(framebuffer, pix, vec4((ray.direction + vec3(1,1,1)) / 2, 1));

    return;
    vec4 result = vec4(0, 0, 0, 1);
    for (float dist = 0; dist < 20; dist += 0.1f)
    {
        vec3 currentPos = ray.origin + ray.direction * dist;
        if (currentPos.y < 0)
        {
            float distFade = 1 - dist / 20.0f;
            result = vec4(distFade, distFade, distFade, 1);
            break;
        }
    }
    imageStore(framebuffer, pix, result);
}
